


## 一、总结
|  类型   |requirements|online metrics|offline metrics|Architecture|feature Engineering|traning data generation|models|其他|
|  -     | -     | -              |  -   |  -        | -   | - | - | - |
|search ranking problem|1. Latency requirements <br> 2. Scale of the data:how many requests per second do we anticipate to handle <br> 3.whether the searcher is a logged-in user or not(profile) |1. click-through rate点击率 <br> 2.successful session rate（session成功率）<br> 3.点击不一定有效（统计花费的时间等）|1. MRP(mean $Reciprocal倒数$ rank): 只关注第一个的排名的倒数 <br> 2. MAP(mean average precision):关注topk结果的排名情况，适用于二进制评分，更细粒度的评分没法做<br>3. NDCG(normolized/IDCG discounted打折/log2(1+i) cumulative累计 gain)：累计收益和/位置discounted/理想排序分数，缺点，没有惩罚相关性为0的节点|1.query <br> 2.query rewriting <br> 3.query understanding <br> 4.Document selection：inverted index，然后再利用term weight，document popularity，intent match， personalization个人信息来排序 <br> 5.Returned Candidates->Ranker->Ranker Results <br> 6.Blender:videos, images, news, blog posts <br> 7.Filtering Results|1. searcher:age gender interest <br>2. query: query prior, query intent <br>3. Document: engagement radius, Document rank <br>4. Context:time of search, Nature of previous queries <br>5. seacher Document:Distance, Historical engagement <br>6. Query-Document Features:BM25, text match, Document click rate, Embedding score|1. pointwise：一次一个数据，可以直接构建成分类的问题或者回归问题，对于大部分为首条点击，可能会缺少负样本，可以随机采样50名以后的样本作为负样本，500w的query可以生成1000w的正负样本数据，另外这个可能跟时间强相关，可以按周来分离数据，前3周训练，最后1周测试。<br> 2. pairwise:同一查询的两个item作为样本，将排序问题转化成二值分类问题，缺点是还是会损失一些细粒度的信息，并且正负样本不平衡问题在这里会被继续放大，优点是衡量了两个的差异。 <br>3. listwise：将整个序列作为样本，直接优化整个信息检索的评价方法，可能一般的评价指标不可微，需要继续做一些可微的优化，数据上，可以参考访问时间来给出label <br>参考1：https://zhuanlan.zhihu.com/p/337478373 <br> 参考2: https://www.cnblogs.com/shona/p/11989041.html|1. ranking stage1: logistic regression, binary classification of results as relevant or irrelevant, AUC ROC <br> 2. Ranking stage2: LambdaMART(树, a few million训练数据) vs LambdaRank(神经网络,更多数据), pairwise objective, NDCG <br> 3. Filtering Results: Logistic regression, MART(Boosted trees or Random Forest) or a Deep neural network, 分类问题, 直接分类来过滤||
|Recommendation System|1.特点：1.1.不同的用户推荐不同的结果。 1.2.多样性，每次推荐的结果可能不一样。Netflix80%的视频都是推荐给用户然后被观看的<br> 2.范围：how many active user。 how many movies。|1.Engagement rate <br> 2.Videos watched <br> 3.session watch time|1.mAP@N <br> 2.f1 <br> 3.预测ratings评分，用MSE|1. user <br> 2.candidates generation: return candidates 3.Ranker:return recommendations|1. user:average session time, language, age, gender <br> 2. user historical interactions: user moving embedding, user-genre historical interaction, user age match <br>3. media based feature:release year, public rating, content tags, move duration <br> 4.context: session of the year, upcoming holiday, time of day, day of week|1. 分类建模（例如正负）数据生成：80%以上为正样本，5%以下为负样本，60%左右丢弃（可能看一半就不想看了）<br> 2.可以根据视频的时间长度做一个加权，因为时间越长你都看完了代表是真的喜欢。|1. condidates generations（多路生成）: 1.1.collaborative filtering 优点：不需要领域知识，缺点：有冷启动数据缺乏问题。<br> 1.2.neural network technique：同协同过滤一样。 <br> 1.3.Content-based filtering:根据用户的profile推荐相关profile的moving <br>2. ranking: <br>2.1.Logistic regression or random forest baseline<br> 2.2.Deep NN with sparse and dense features|推荐的结果其实是有偏的，因为这些数据被观看次数多，有更多的训练数据，利用这些数据训练可能还是偏向于这些数据，可以利用随机推荐，拿到一些无偏的训练数据来用作模型训练|